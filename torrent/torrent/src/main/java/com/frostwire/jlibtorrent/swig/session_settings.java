/* ----------------------------------------------------------------------------
 * This file was automatically generated by SWIG (http://www.swig.org).
 * Version 3.0.2
 *
 * Do not make changes to this file unless you know what you are doing--modify
 * the SWIG interface file instead.
 * ----------------------------------------------------------------------------- */

package com.frostwire.jlibtorrent.swig;

public class session_settings {
  private long swigCPtr;
  protected boolean swigCMemOwn;

  protected session_settings(long cPtr, boolean cMemoryOwn) {
    swigCMemOwn = cMemoryOwn;
    swigCPtr = cPtr;
  }

  protected static long getCPtr(session_settings obj) {
    return (obj == null) ? 0 : obj.swigCPtr;
  }

  protected void finalize() {
    delete();
  }

  public synchronized void delete() {
    if (swigCPtr != 0) {
      if (swigCMemOwn) {
        swigCMemOwn = false;
        libtorrent_jni.delete_session_settings(swigCPtr);
      }
      swigCPtr = 0;
    }
  }

  public session_settings(String user_agent) {
    this(libtorrent_jni.new_session_settings__SWIG_0(user_agent), true);
  }

  public session_settings() {
    this(libtorrent_jni.new_session_settings__SWIG_1(), true);
  }

  public void setVersion(int value) {
    libtorrent_jni.session_settings_version_set(swigCPtr, this, value);
  }

  public int getVersion() {
    return libtorrent_jni.session_settings_version_get(swigCPtr, this);
  }

  public void setUser_agent(String value) {
    libtorrent_jni.session_settings_user_agent_set(swigCPtr, this, value);
  }

  public String getUser_agent() {
    return libtorrent_jni.session_settings_user_agent_get(swigCPtr, this);
  }

  public void setTracker_completion_timeout(int value) {
    libtorrent_jni.session_settings_tracker_completion_timeout_set(swigCPtr, this, value);
  }

  public int getTracker_completion_timeout() {
    return libtorrent_jni.session_settings_tracker_completion_timeout_get(swigCPtr, this);
  }

  public void setTracker_receive_timeout(int value) {
    libtorrent_jni.session_settings_tracker_receive_timeout_set(swigCPtr, this, value);
  }

  public int getTracker_receive_timeout() {
    return libtorrent_jni.session_settings_tracker_receive_timeout_get(swigCPtr, this);
  }

  public void setStop_tracker_timeout(int value) {
    libtorrent_jni.session_settings_stop_tracker_timeout_set(swigCPtr, this, value);
  }

  public int getStop_tracker_timeout() {
    return libtorrent_jni.session_settings_stop_tracker_timeout_get(swigCPtr, this);
  }

  public void setTracker_maximum_response_length(int value) {
    libtorrent_jni.session_settings_tracker_maximum_response_length_set(swigCPtr, this, value);
  }

  public int getTracker_maximum_response_length() {
    return libtorrent_jni.session_settings_tracker_maximum_response_length_get(swigCPtr, this);
  }

  public void setPiece_timeout(int value) {
    libtorrent_jni.session_settings_piece_timeout_set(swigCPtr, this, value);
  }

  public int getPiece_timeout() {
    return libtorrent_jni.session_settings_piece_timeout_get(swigCPtr, this);
  }

  public void setRequest_timeout(int value) {
    libtorrent_jni.session_settings_request_timeout_set(swigCPtr, this, value);
  }

  public int getRequest_timeout() {
    return libtorrent_jni.session_settings_request_timeout_get(swigCPtr, this);
  }

  public void setRequest_queue_time(int value) {
    libtorrent_jni.session_settings_request_queue_time_set(swigCPtr, this, value);
  }

  public int getRequest_queue_time() {
    return libtorrent_jni.session_settings_request_queue_time_get(swigCPtr, this);
  }

  public void setMax_allowed_in_request_queue(int value) {
    libtorrent_jni.session_settings_max_allowed_in_request_queue_set(swigCPtr, this, value);
  }

  public int getMax_allowed_in_request_queue() {
    return libtorrent_jni.session_settings_max_allowed_in_request_queue_get(swigCPtr, this);
  }

  public void setMax_out_request_queue(int value) {
    libtorrent_jni.session_settings_max_out_request_queue_set(swigCPtr, this, value);
  }

  public int getMax_out_request_queue() {
    return libtorrent_jni.session_settings_max_out_request_queue_get(swigCPtr, this);
  }

  public void setWhole_pieces_threshold(int value) {
    libtorrent_jni.session_settings_whole_pieces_threshold_set(swigCPtr, this, value);
  }

  public int getWhole_pieces_threshold() {
    return libtorrent_jni.session_settings_whole_pieces_threshold_get(swigCPtr, this);
  }

  public void setPeer_timeout(int value) {
    libtorrent_jni.session_settings_peer_timeout_set(swigCPtr, this, value);
  }

  public int getPeer_timeout() {
    return libtorrent_jni.session_settings_peer_timeout_get(swigCPtr, this);
  }

  public void setUrlseed_timeout(int value) {
    libtorrent_jni.session_settings_urlseed_timeout_set(swigCPtr, this, value);
  }

  public int getUrlseed_timeout() {
    return libtorrent_jni.session_settings_urlseed_timeout_get(swigCPtr, this);
  }

  public void setUrlseed_pipeline_size(int value) {
    libtorrent_jni.session_settings_urlseed_pipeline_size_set(swigCPtr, this, value);
  }

  public int getUrlseed_pipeline_size() {
    return libtorrent_jni.session_settings_urlseed_pipeline_size_get(swigCPtr, this);
  }

  public void setUrlseed_wait_retry(int value) {
    libtorrent_jni.session_settings_urlseed_wait_retry_set(swigCPtr, this, value);
  }

  public int getUrlseed_wait_retry() {
    return libtorrent_jni.session_settings_urlseed_wait_retry_get(swigCPtr, this);
  }

  public void setFile_pool_size(int value) {
    libtorrent_jni.session_settings_file_pool_size_set(swigCPtr, this, value);
  }

  public int getFile_pool_size() {
    return libtorrent_jni.session_settings_file_pool_size_get(swigCPtr, this);
  }

  public void setAllow_multiple_connections_per_ip(boolean value) {
    libtorrent_jni.session_settings_allow_multiple_connections_per_ip_set(swigCPtr, this, value);
  }

  public boolean getAllow_multiple_connections_per_ip() {
    return libtorrent_jni.session_settings_allow_multiple_connections_per_ip_get(swigCPtr, this);
  }

  public void setMax_failcount(int value) {
    libtorrent_jni.session_settings_max_failcount_set(swigCPtr, this, value);
  }

  public int getMax_failcount() {
    return libtorrent_jni.session_settings_max_failcount_get(swigCPtr, this);
  }

  public void setMin_reconnect_time(int value) {
    libtorrent_jni.session_settings_min_reconnect_time_set(swigCPtr, this, value);
  }

  public int getMin_reconnect_time() {
    return libtorrent_jni.session_settings_min_reconnect_time_get(swigCPtr, this);
  }

  public void setPeer_connect_timeout(int value) {
    libtorrent_jni.session_settings_peer_connect_timeout_set(swigCPtr, this, value);
  }

  public int getPeer_connect_timeout() {
    return libtorrent_jni.session_settings_peer_connect_timeout_get(swigCPtr, this);
  }

  public void setIgnore_limits_on_local_network(boolean value) {
    libtorrent_jni.session_settings_ignore_limits_on_local_network_set(swigCPtr, this, value);
  }

  public boolean getIgnore_limits_on_local_network() {
    return libtorrent_jni.session_settings_ignore_limits_on_local_network_get(swigCPtr, this);
  }

  public void setConnection_speed(int value) {
    libtorrent_jni.session_settings_connection_speed_set(swigCPtr, this, value);
  }

  public int getConnection_speed() {
    return libtorrent_jni.session_settings_connection_speed_get(swigCPtr, this);
  }

  public void setSend_redundant_have(boolean value) {
    libtorrent_jni.session_settings_send_redundant_have_set(swigCPtr, this, value);
  }

  public boolean getSend_redundant_have() {
    return libtorrent_jni.session_settings_send_redundant_have_get(swigCPtr, this);
  }

  public void setLazy_bitfields(boolean value) {
    libtorrent_jni.session_settings_lazy_bitfields_set(swigCPtr, this, value);
  }

  public boolean getLazy_bitfields() {
    return libtorrent_jni.session_settings_lazy_bitfields_get(swigCPtr, this);
  }

  public void setInactivity_timeout(int value) {
    libtorrent_jni.session_settings_inactivity_timeout_set(swigCPtr, this, value);
  }

  public int getInactivity_timeout() {
    return libtorrent_jni.session_settings_inactivity_timeout_get(swigCPtr, this);
  }

  public void setUnchoke_interval(int value) {
    libtorrent_jni.session_settings_unchoke_interval_set(swigCPtr, this, value);
  }

  public int getUnchoke_interval() {
    return libtorrent_jni.session_settings_unchoke_interval_get(swigCPtr, this);
  }

  public void setOptimistic_unchoke_interval(int value) {
    libtorrent_jni.session_settings_optimistic_unchoke_interval_set(swigCPtr, this, value);
  }

  public int getOptimistic_unchoke_interval() {
    return libtorrent_jni.session_settings_optimistic_unchoke_interval_get(swigCPtr, this);
  }

  public void setAnnounce_ip(String value) {
    libtorrent_jni.session_settings_announce_ip_set(swigCPtr, this, value);
  }

  public String getAnnounce_ip() {
    return libtorrent_jni.session_settings_announce_ip_get(swigCPtr, this);
  }

  public void setNum_want(int value) {
    libtorrent_jni.session_settings_num_want_set(swigCPtr, this, value);
  }

  public int getNum_want() {
    return libtorrent_jni.session_settings_num_want_get(swigCPtr, this);
  }

  public void setInitial_picker_threshold(int value) {
    libtorrent_jni.session_settings_initial_picker_threshold_set(swigCPtr, this, value);
  }

  public int getInitial_picker_threshold() {
    return libtorrent_jni.session_settings_initial_picker_threshold_get(swigCPtr, this);
  }

  public void setAllowed_fast_set_size(int value) {
    libtorrent_jni.session_settings_allowed_fast_set_size_set(swigCPtr, this, value);
  }

  public int getAllowed_fast_set_size() {
    return libtorrent_jni.session_settings_allowed_fast_set_size_get(swigCPtr, this);
  }

  public void setSuggest_mode(int value) {
    libtorrent_jni.session_settings_suggest_mode_set(swigCPtr, this, value);
  }

  public int getSuggest_mode() {
    return libtorrent_jni.session_settings_suggest_mode_get(swigCPtr, this);
  }

  public void setMax_queued_disk_bytes(int value) {
    libtorrent_jni.session_settings_max_queued_disk_bytes_set(swigCPtr, this, value);
  }

  public int getMax_queued_disk_bytes() {
    return libtorrent_jni.session_settings_max_queued_disk_bytes_get(swigCPtr, this);
  }

  public void setMax_queued_disk_bytes_low_watermark(int value) {
    libtorrent_jni.session_settings_max_queued_disk_bytes_low_watermark_set(swigCPtr, this, value);
  }

  public int getMax_queued_disk_bytes_low_watermark() {
    return libtorrent_jni.session_settings_max_queued_disk_bytes_low_watermark_get(swigCPtr, this);
  }

  public void setHandshake_timeout(int value) {
    libtorrent_jni.session_settings_handshake_timeout_set(swigCPtr, this, value);
  }

  public int getHandshake_timeout() {
    return libtorrent_jni.session_settings_handshake_timeout_get(swigCPtr, this);
  }

  public void setUse_dht_as_fallback(boolean value) {
    libtorrent_jni.session_settings_use_dht_as_fallback_set(swigCPtr, this, value);
  }

  public boolean getUse_dht_as_fallback() {
    return libtorrent_jni.session_settings_use_dht_as_fallback_get(swigCPtr, this);
  }

  public void setFree_torrent_hashes(boolean value) {
    libtorrent_jni.session_settings_free_torrent_hashes_set(swigCPtr, this, value);
  }

  public boolean getFree_torrent_hashes() {
    return libtorrent_jni.session_settings_free_torrent_hashes_get(swigCPtr, this);
  }

  public void setUpnp_ignore_nonrouters(boolean value) {
    libtorrent_jni.session_settings_upnp_ignore_nonrouters_set(swigCPtr, this, value);
  }

  public boolean getUpnp_ignore_nonrouters() {
    return libtorrent_jni.session_settings_upnp_ignore_nonrouters_get(swigCPtr, this);
  }

  public void setSend_buffer_low_watermark(int value) {
    libtorrent_jni.session_settings_send_buffer_low_watermark_set(swigCPtr, this, value);
  }

  public int getSend_buffer_low_watermark() {
    return libtorrent_jni.session_settings_send_buffer_low_watermark_get(swigCPtr, this);
  }

  public void setSend_buffer_watermark(int value) {
    libtorrent_jni.session_settings_send_buffer_watermark_set(swigCPtr, this, value);
  }

  public int getSend_buffer_watermark() {
    return libtorrent_jni.session_settings_send_buffer_watermark_get(swigCPtr, this);
  }

  public void setSend_buffer_watermark_factor(int value) {
    libtorrent_jni.session_settings_send_buffer_watermark_factor_set(swigCPtr, this, value);
  }

  public int getSend_buffer_watermark_factor() {
    return libtorrent_jni.session_settings_send_buffer_watermark_factor_get(swigCPtr, this);
  }

  public void setChoking_algorithm(int value) {
    libtorrent_jni.session_settings_choking_algorithm_set(swigCPtr, this, value);
  }

  public int getChoking_algorithm() {
    return libtorrent_jni.session_settings_choking_algorithm_get(swigCPtr, this);
  }

  public void setSeed_choking_algorithm(int value) {
    libtorrent_jni.session_settings_seed_choking_algorithm_set(swigCPtr, this, value);
  }

  public int getSeed_choking_algorithm() {
    return libtorrent_jni.session_settings_seed_choking_algorithm_get(swigCPtr, this);
  }

  public void setUse_parole_mode(boolean value) {
    libtorrent_jni.session_settings_use_parole_mode_set(swigCPtr, this, value);
  }

  public boolean getUse_parole_mode() {
    return libtorrent_jni.session_settings_use_parole_mode_get(swigCPtr, this);
  }

  public void setCache_size(int value) {
    libtorrent_jni.session_settings_cache_size_set(swigCPtr, this, value);
  }

  public int getCache_size() {
    return libtorrent_jni.session_settings_cache_size_get(swigCPtr, this);
  }

  public void setCache_buffer_chunk_size(int value) {
    libtorrent_jni.session_settings_cache_buffer_chunk_size_set(swigCPtr, this, value);
  }

  public int getCache_buffer_chunk_size() {
    return libtorrent_jni.session_settings_cache_buffer_chunk_size_get(swigCPtr, this);
  }

  public void setCache_expiry(int value) {
    libtorrent_jni.session_settings_cache_expiry_set(swigCPtr, this, value);
  }

  public int getCache_expiry() {
    return libtorrent_jni.session_settings_cache_expiry_get(swigCPtr, this);
  }

  public void setUse_read_cache(boolean value) {
    libtorrent_jni.session_settings_use_read_cache_set(swigCPtr, this, value);
  }

  public boolean getUse_read_cache() {
    return libtorrent_jni.session_settings_use_read_cache_get(swigCPtr, this);
  }

  public void setExplicit_read_cache(boolean value) {
    libtorrent_jni.session_settings_explicit_read_cache_set(swigCPtr, this, value);
  }

  public boolean getExplicit_read_cache() {
    return libtorrent_jni.session_settings_explicit_read_cache_get(swigCPtr, this);
  }

  public void setExplicit_cache_interval(int value) {
    libtorrent_jni.session_settings_explicit_cache_interval_set(swigCPtr, this, value);
  }

  public int getExplicit_cache_interval() {
    return libtorrent_jni.session_settings_explicit_cache_interval_get(swigCPtr, this);
  }

  public void setDisk_io_write_mode(int value) {
    libtorrent_jni.session_settings_disk_io_write_mode_set(swigCPtr, this, value);
  }

  public int getDisk_io_write_mode() {
    return libtorrent_jni.session_settings_disk_io_write_mode_get(swigCPtr, this);
  }

  public void setDisk_io_read_mode(int value) {
    libtorrent_jni.session_settings_disk_io_read_mode_set(swigCPtr, this, value);
  }

  public int getDisk_io_read_mode() {
    return libtorrent_jni.session_settings_disk_io_read_mode_get(swigCPtr, this);
  }

  public void setCoalesce_reads(boolean value) {
    libtorrent_jni.session_settings_coalesce_reads_set(swigCPtr, this, value);
  }

  public boolean getCoalesce_reads() {
    return libtorrent_jni.session_settings_coalesce_reads_get(swigCPtr, this);
  }

  public void setCoalesce_writes(boolean value) {
    libtorrent_jni.session_settings_coalesce_writes_set(swigCPtr, this, value);
  }

  public boolean getCoalesce_writes() {
    return libtorrent_jni.session_settings_coalesce_writes_get(swigCPtr, this);
  }

  public void setOutgoing_ports(int_int_pair value) {
    libtorrent_jni.session_settings_outgoing_ports_set(swigCPtr, this, int_int_pair.getCPtr(value), value);
  }

  public int_int_pair getOutgoing_ports() {
    long cPtr = libtorrent_jni.session_settings_outgoing_ports_get(swigCPtr, this);
    return (cPtr == 0) ? null : new int_int_pair(cPtr, false);
  }

  public void setPeer_tos(char value) {
    libtorrent_jni.session_settings_peer_tos_set(swigCPtr, this, value);
  }

  public char getPeer_tos() {
    return libtorrent_jni.session_settings_peer_tos_get(swigCPtr, this);
  }

  public void setActive_downloads(int value) {
    libtorrent_jni.session_settings_active_downloads_set(swigCPtr, this, value);
  }

  public int getActive_downloads() {
    return libtorrent_jni.session_settings_active_downloads_get(swigCPtr, this);
  }

  public void setActive_seeds(int value) {
    libtorrent_jni.session_settings_active_seeds_set(swigCPtr, this, value);
  }

  public int getActive_seeds() {
    return libtorrent_jni.session_settings_active_seeds_get(swigCPtr, this);
  }

  public void setActive_dht_limit(int value) {
    libtorrent_jni.session_settings_active_dht_limit_set(swigCPtr, this, value);
  }

  public int getActive_dht_limit() {
    return libtorrent_jni.session_settings_active_dht_limit_get(swigCPtr, this);
  }

  public void setActive_tracker_limit(int value) {
    libtorrent_jni.session_settings_active_tracker_limit_set(swigCPtr, this, value);
  }

  public int getActive_tracker_limit() {
    return libtorrent_jni.session_settings_active_tracker_limit_get(swigCPtr, this);
  }

  public void setActive_lsd_limit(int value) {
    libtorrent_jni.session_settings_active_lsd_limit_set(swigCPtr, this, value);
  }

  public int getActive_lsd_limit() {
    return libtorrent_jni.session_settings_active_lsd_limit_get(swigCPtr, this);
  }

  public void setActive_limit(int value) {
    libtorrent_jni.session_settings_active_limit_set(swigCPtr, this, value);
  }

  public int getActive_limit() {
    return libtorrent_jni.session_settings_active_limit_get(swigCPtr, this);
  }

  public void setAuto_manage_prefer_seeds(boolean value) {
    libtorrent_jni.session_settings_auto_manage_prefer_seeds_set(swigCPtr, this, value);
  }

  public boolean getAuto_manage_prefer_seeds() {
    return libtorrent_jni.session_settings_auto_manage_prefer_seeds_get(swigCPtr, this);
  }

  public void setDont_count_slow_torrents(boolean value) {
    libtorrent_jni.session_settings_dont_count_slow_torrents_set(swigCPtr, this, value);
  }

  public boolean getDont_count_slow_torrents() {
    return libtorrent_jni.session_settings_dont_count_slow_torrents_get(swigCPtr, this);
  }

  public void setAuto_manage_interval(int value) {
    libtorrent_jni.session_settings_auto_manage_interval_set(swigCPtr, this, value);
  }

  public int getAuto_manage_interval() {
    return libtorrent_jni.session_settings_auto_manage_interval_get(swigCPtr, this);
  }

  public void setShare_ratio_limit(float value) {
    libtorrent_jni.session_settings_share_ratio_limit_set(swigCPtr, this, value);
  }

  public float getShare_ratio_limit() {
    return libtorrent_jni.session_settings_share_ratio_limit_get(swigCPtr, this);
  }

  public void setSeed_time_ratio_limit(float value) {
    libtorrent_jni.session_settings_seed_time_ratio_limit_set(swigCPtr, this, value);
  }

  public float getSeed_time_ratio_limit() {
    return libtorrent_jni.session_settings_seed_time_ratio_limit_get(swigCPtr, this);
  }

  public void setSeed_time_limit(int value) {
    libtorrent_jni.session_settings_seed_time_limit_set(swigCPtr, this, value);
  }

  public int getSeed_time_limit() {
    return libtorrent_jni.session_settings_seed_time_limit_get(swigCPtr, this);
  }

  public void setPeer_turnover_interval(int value) {
    libtorrent_jni.session_settings_peer_turnover_interval_set(swigCPtr, this, value);
  }

  public int getPeer_turnover_interval() {
    return libtorrent_jni.session_settings_peer_turnover_interval_get(swigCPtr, this);
  }

  public void setPeer_turnover(float value) {
    libtorrent_jni.session_settings_peer_turnover_set(swigCPtr, this, value);
  }

  public float getPeer_turnover() {
    return libtorrent_jni.session_settings_peer_turnover_get(swigCPtr, this);
  }

  public void setPeer_turnover_cutoff(float value) {
    libtorrent_jni.session_settings_peer_turnover_cutoff_set(swigCPtr, this, value);
  }

  public float getPeer_turnover_cutoff() {
    return libtorrent_jni.session_settings_peer_turnover_cutoff_get(swigCPtr, this);
  }

  public void setClose_redundant_connections(boolean value) {
    libtorrent_jni.session_settings_close_redundant_connections_set(swigCPtr, this, value);
  }

  public boolean getClose_redundant_connections() {
    return libtorrent_jni.session_settings_close_redundant_connections_get(swigCPtr, this);
  }

  public void setAuto_scrape_interval(int value) {
    libtorrent_jni.session_settings_auto_scrape_interval_set(swigCPtr, this, value);
  }

  public int getAuto_scrape_interval() {
    return libtorrent_jni.session_settings_auto_scrape_interval_get(swigCPtr, this);
  }

  public void setAuto_scrape_min_interval(int value) {
    libtorrent_jni.session_settings_auto_scrape_min_interval_set(swigCPtr, this, value);
  }

  public int getAuto_scrape_min_interval() {
    return libtorrent_jni.session_settings_auto_scrape_min_interval_get(swigCPtr, this);
  }

  public void setMax_peerlist_size(int value) {
    libtorrent_jni.session_settings_max_peerlist_size_set(swigCPtr, this, value);
  }

  public int getMax_peerlist_size() {
    return libtorrent_jni.session_settings_max_peerlist_size_get(swigCPtr, this);
  }

  public void setMax_paused_peerlist_size(int value) {
    libtorrent_jni.session_settings_max_paused_peerlist_size_set(swigCPtr, this, value);
  }

  public int getMax_paused_peerlist_size() {
    return libtorrent_jni.session_settings_max_paused_peerlist_size_get(swigCPtr, this);
  }

  public void setMin_announce_interval(int value) {
    libtorrent_jni.session_settings_min_announce_interval_set(swigCPtr, this, value);
  }

  public int getMin_announce_interval() {
    return libtorrent_jni.session_settings_min_announce_interval_get(swigCPtr, this);
  }

  public void setPrioritize_partial_pieces(boolean value) {
    libtorrent_jni.session_settings_prioritize_partial_pieces_set(swigCPtr, this, value);
  }

  public boolean getPrioritize_partial_pieces() {
    return libtorrent_jni.session_settings_prioritize_partial_pieces_get(swigCPtr, this);
  }

  public void setAuto_manage_startup(int value) {
    libtorrent_jni.session_settings_auto_manage_startup_set(swigCPtr, this, value);
  }

  public int getAuto_manage_startup() {
    return libtorrent_jni.session_settings_auto_manage_startup_get(swigCPtr, this);
  }

  public void setRate_limit_ip_overhead(boolean value) {
    libtorrent_jni.session_settings_rate_limit_ip_overhead_set(swigCPtr, this, value);
  }

  public boolean getRate_limit_ip_overhead() {
    return libtorrent_jni.session_settings_rate_limit_ip_overhead_get(swigCPtr, this);
  }

  public void setAnnounce_to_all_trackers(boolean value) {
    libtorrent_jni.session_settings_announce_to_all_trackers_set(swigCPtr, this, value);
  }

  public boolean getAnnounce_to_all_trackers() {
    return libtorrent_jni.session_settings_announce_to_all_trackers_get(swigCPtr, this);
  }

  public void setAnnounce_to_all_tiers(boolean value) {
    libtorrent_jni.session_settings_announce_to_all_tiers_set(swigCPtr, this, value);
  }

  public boolean getAnnounce_to_all_tiers() {
    return libtorrent_jni.session_settings_announce_to_all_tiers_get(swigCPtr, this);
  }

  public void setPrefer_udp_trackers(boolean value) {
    libtorrent_jni.session_settings_prefer_udp_trackers_set(swigCPtr, this, value);
  }

  public boolean getPrefer_udp_trackers() {
    return libtorrent_jni.session_settings_prefer_udp_trackers_get(swigCPtr, this);
  }

  public void setStrict_super_seeding(boolean value) {
    libtorrent_jni.session_settings_strict_super_seeding_set(swigCPtr, this, value);
  }

  public boolean getStrict_super_seeding() {
    return libtorrent_jni.session_settings_strict_super_seeding_get(swigCPtr, this);
  }

  public void setSeeding_piece_quota(int value) {
    libtorrent_jni.session_settings_seeding_piece_quota_set(swigCPtr, this, value);
  }

  public int getSeeding_piece_quota() {
    return libtorrent_jni.session_settings_seeding_piece_quota_get(swigCPtr, this);
  }

  public void setMax_sparse_regions(int value) {
    libtorrent_jni.session_settings_max_sparse_regions_set(swigCPtr, this, value);
  }

  public int getMax_sparse_regions() {
    return libtorrent_jni.session_settings_max_sparse_regions_get(swigCPtr, this);
  }

  public void setLock_disk_cache(boolean value) {
    libtorrent_jni.session_settings_lock_disk_cache_set(swigCPtr, this, value);
  }

  public boolean getLock_disk_cache() {
    return libtorrent_jni.session_settings_lock_disk_cache_get(swigCPtr, this);
  }

  public void setMax_rejects(int value) {
    libtorrent_jni.session_settings_max_rejects_set(swigCPtr, this, value);
  }

  public int getMax_rejects() {
    return libtorrent_jni.session_settings_max_rejects_get(swigCPtr, this);
  }

  public void setRecv_socket_buffer_size(int value) {
    libtorrent_jni.session_settings_recv_socket_buffer_size_set(swigCPtr, this, value);
  }

  public int getRecv_socket_buffer_size() {
    return libtorrent_jni.session_settings_recv_socket_buffer_size_get(swigCPtr, this);
  }

  public void setSend_socket_buffer_size(int value) {
    libtorrent_jni.session_settings_send_socket_buffer_size_set(swigCPtr, this, value);
  }

  public int getSend_socket_buffer_size() {
    return libtorrent_jni.session_settings_send_socket_buffer_size_get(swigCPtr, this);
  }

  public void setOptimize_hashing_for_speed(boolean value) {
    libtorrent_jni.session_settings_optimize_hashing_for_speed_set(swigCPtr, this, value);
  }

  public boolean getOptimize_hashing_for_speed() {
    return libtorrent_jni.session_settings_optimize_hashing_for_speed_get(swigCPtr, this);
  }

  public void setFile_checks_delay_per_block(int value) {
    libtorrent_jni.session_settings_file_checks_delay_per_block_set(swigCPtr, this, value);
  }

  public int getFile_checks_delay_per_block() {
    return libtorrent_jni.session_settings_file_checks_delay_per_block_get(swigCPtr, this);
  }

  public void setDisk_cache_algorithm(disk_cache_algo_t value) {
    libtorrent_jni.session_settings_disk_cache_algorithm_set(swigCPtr, this, value.swigValue());
  }

  public disk_cache_algo_t getDisk_cache_algorithm() {
    return disk_cache_algo_t.swigToEnum(libtorrent_jni.session_settings_disk_cache_algorithm_get(swigCPtr, this));
  }

  public void setRead_cache_line_size(int value) {
    libtorrent_jni.session_settings_read_cache_line_size_set(swigCPtr, this, value);
  }

  public int getRead_cache_line_size() {
    return libtorrent_jni.session_settings_read_cache_line_size_get(swigCPtr, this);
  }

  public void setWrite_cache_line_size(int value) {
    libtorrent_jni.session_settings_write_cache_line_size_set(swigCPtr, this, value);
  }

  public int getWrite_cache_line_size() {
    return libtorrent_jni.session_settings_write_cache_line_size_get(swigCPtr, this);
  }

  public void setOptimistic_disk_retry(int value) {
    libtorrent_jni.session_settings_optimistic_disk_retry_set(swigCPtr, this, value);
  }

  public int getOptimistic_disk_retry() {
    return libtorrent_jni.session_settings_optimistic_disk_retry_get(swigCPtr, this);
  }

  public void setDisable_hash_checks(boolean value) {
    libtorrent_jni.session_settings_disable_hash_checks_set(swigCPtr, this, value);
  }

  public boolean getDisable_hash_checks() {
    return libtorrent_jni.session_settings_disable_hash_checks_get(swigCPtr, this);
  }

  public void setAllow_reordered_disk_operations(boolean value) {
    libtorrent_jni.session_settings_allow_reordered_disk_operations_set(swigCPtr, this, value);
  }

  public boolean getAllow_reordered_disk_operations() {
    return libtorrent_jni.session_settings_allow_reordered_disk_operations_get(swigCPtr, this);
  }

  public void setAllow_i2p_mixed(boolean value) {
    libtorrent_jni.session_settings_allow_i2p_mixed_set(swigCPtr, this, value);
  }

  public boolean getAllow_i2p_mixed() {
    return libtorrent_jni.session_settings_allow_i2p_mixed_get(swigCPtr, this);
  }

  public void setMax_suggest_pieces(int value) {
    libtorrent_jni.session_settings_max_suggest_pieces_set(swigCPtr, this, value);
  }

  public int getMax_suggest_pieces() {
    return libtorrent_jni.session_settings_max_suggest_pieces_get(swigCPtr, this);
  }

  public void setDrop_skipped_requests(boolean value) {
    libtorrent_jni.session_settings_drop_skipped_requests_set(swigCPtr, this, value);
  }

  public boolean getDrop_skipped_requests() {
    return libtorrent_jni.session_settings_drop_skipped_requests_get(swigCPtr, this);
  }

  public void setLow_prio_disk(boolean value) {
    libtorrent_jni.session_settings_low_prio_disk_set(swigCPtr, this, value);
  }

  public boolean getLow_prio_disk() {
    return libtorrent_jni.session_settings_low_prio_disk_get(swigCPtr, this);
  }

  public void setLocal_service_announce_interval(int value) {
    libtorrent_jni.session_settings_local_service_announce_interval_set(swigCPtr, this, value);
  }

  public int getLocal_service_announce_interval() {
    return libtorrent_jni.session_settings_local_service_announce_interval_get(swigCPtr, this);
  }

  public void setDht_announce_interval(int value) {
    libtorrent_jni.session_settings_dht_announce_interval_set(swigCPtr, this, value);
  }

  public int getDht_announce_interval() {
    return libtorrent_jni.session_settings_dht_announce_interval_get(swigCPtr, this);
  }

  public void setUdp_tracker_token_expiry(int value) {
    libtorrent_jni.session_settings_udp_tracker_token_expiry_set(swigCPtr, this, value);
  }

  public int getUdp_tracker_token_expiry() {
    return libtorrent_jni.session_settings_udp_tracker_token_expiry_get(swigCPtr, this);
  }

  public void setVolatile_read_cache(boolean value) {
    libtorrent_jni.session_settings_volatile_read_cache_set(swigCPtr, this, value);
  }

  public boolean getVolatile_read_cache() {
    return libtorrent_jni.session_settings_volatile_read_cache_get(swigCPtr, this);
  }

  public void setGuided_read_cache(boolean value) {
    libtorrent_jni.session_settings_guided_read_cache_set(swigCPtr, this, value);
  }

  public boolean getGuided_read_cache() {
    return libtorrent_jni.session_settings_guided_read_cache_get(swigCPtr, this);
  }

  public void setDefault_cache_min_age(int value) {
    libtorrent_jni.session_settings_default_cache_min_age_set(swigCPtr, this, value);
  }

  public int getDefault_cache_min_age() {
    return libtorrent_jni.session_settings_default_cache_min_age_get(swigCPtr, this);
  }

  public void setNum_optimistic_unchoke_slots(int value) {
    libtorrent_jni.session_settings_num_optimistic_unchoke_slots_set(swigCPtr, this, value);
  }

  public int getNum_optimistic_unchoke_slots() {
    return libtorrent_jni.session_settings_num_optimistic_unchoke_slots_get(swigCPtr, this);
  }

  public void setNo_atime_storage(boolean value) {
    libtorrent_jni.session_settings_no_atime_storage_set(swigCPtr, this, value);
  }

  public boolean getNo_atime_storage() {
    return libtorrent_jni.session_settings_no_atime_storage_get(swigCPtr, this);
  }

  public void setDefault_est_reciprocation_rate(int value) {
    libtorrent_jni.session_settings_default_est_reciprocation_rate_set(swigCPtr, this, value);
  }

  public int getDefault_est_reciprocation_rate() {
    return libtorrent_jni.session_settings_default_est_reciprocation_rate_get(swigCPtr, this);
  }

  public void setIncrease_est_reciprocation_rate(int value) {
    libtorrent_jni.session_settings_increase_est_reciprocation_rate_set(swigCPtr, this, value);
  }

  public int getIncrease_est_reciprocation_rate() {
    return libtorrent_jni.session_settings_increase_est_reciprocation_rate_get(swigCPtr, this);
  }

  public void setDecrease_est_reciprocation_rate(int value) {
    libtorrent_jni.session_settings_decrease_est_reciprocation_rate_set(swigCPtr, this, value);
  }

  public int getDecrease_est_reciprocation_rate() {
    return libtorrent_jni.session_settings_decrease_est_reciprocation_rate_get(swigCPtr, this);
  }

  public void setIncoming_starts_queued_torrents(boolean value) {
    libtorrent_jni.session_settings_incoming_starts_queued_torrents_set(swigCPtr, this, value);
  }

  public boolean getIncoming_starts_queued_torrents() {
    return libtorrent_jni.session_settings_incoming_starts_queued_torrents_get(swigCPtr, this);
  }

  public void setReport_true_downloaded(boolean value) {
    libtorrent_jni.session_settings_report_true_downloaded_set(swigCPtr, this, value);
  }

  public boolean getReport_true_downloaded() {
    return libtorrent_jni.session_settings_report_true_downloaded_get(swigCPtr, this);
  }

  public void setStrict_end_game_mode(boolean value) {
    libtorrent_jni.session_settings_strict_end_game_mode_set(swigCPtr, this, value);
  }

  public boolean getStrict_end_game_mode() {
    return libtorrent_jni.session_settings_strict_end_game_mode_get(swigCPtr, this);
  }

  public void setBroadcast_lsd(boolean value) {
    libtorrent_jni.session_settings_broadcast_lsd_set(swigCPtr, this, value);
  }

  public boolean getBroadcast_lsd() {
    return libtorrent_jni.session_settings_broadcast_lsd_get(swigCPtr, this);
  }

  public void setEnable_outgoing_utp(boolean value) {
    libtorrent_jni.session_settings_enable_outgoing_utp_set(swigCPtr, this, value);
  }

  public boolean getEnable_outgoing_utp() {
    return libtorrent_jni.session_settings_enable_outgoing_utp_get(swigCPtr, this);
  }

  public void setEnable_incoming_utp(boolean value) {
    libtorrent_jni.session_settings_enable_incoming_utp_set(swigCPtr, this, value);
  }

  public boolean getEnable_incoming_utp() {
    return libtorrent_jni.session_settings_enable_incoming_utp_get(swigCPtr, this);
  }

  public void setEnable_outgoing_tcp(boolean value) {
    libtorrent_jni.session_settings_enable_outgoing_tcp_set(swigCPtr, this, value);
  }

  public boolean getEnable_outgoing_tcp() {
    return libtorrent_jni.session_settings_enable_outgoing_tcp_get(swigCPtr, this);
  }

  public void setEnable_incoming_tcp(boolean value) {
    libtorrent_jni.session_settings_enable_incoming_tcp_set(swigCPtr, this, value);
  }

  public boolean getEnable_incoming_tcp() {
    return libtorrent_jni.session_settings_enable_incoming_tcp_get(swigCPtr, this);
  }

  public void setMax_pex_peers(int value) {
    libtorrent_jni.session_settings_max_pex_peers_set(swigCPtr, this, value);
  }

  public int getMax_pex_peers() {
    return libtorrent_jni.session_settings_max_pex_peers_get(swigCPtr, this);
  }

  public void setIgnore_resume_timestamps(boolean value) {
    libtorrent_jni.session_settings_ignore_resume_timestamps_set(swigCPtr, this, value);
  }

  public boolean getIgnore_resume_timestamps() {
    return libtorrent_jni.session_settings_ignore_resume_timestamps_get(swigCPtr, this);
  }

  public void setNo_recheck_incomplete_resume(boolean value) {
    libtorrent_jni.session_settings_no_recheck_incomplete_resume_set(swigCPtr, this, value);
  }

  public boolean getNo_recheck_incomplete_resume() {
    return libtorrent_jni.session_settings_no_recheck_incomplete_resume_get(swigCPtr, this);
  }

  public void setAnonymous_mode(boolean value) {
    libtorrent_jni.session_settings_anonymous_mode_set(swigCPtr, this, value);
  }

  public boolean getAnonymous_mode() {
    return libtorrent_jni.session_settings_anonymous_mode_get(swigCPtr, this);
  }

  public void setForce_proxy(boolean value) {
    libtorrent_jni.session_settings_force_proxy_set(swigCPtr, this, value);
  }

  public boolean getForce_proxy() {
    return libtorrent_jni.session_settings_force_proxy_get(swigCPtr, this);
  }

  public void setTick_interval(int value) {
    libtorrent_jni.session_settings_tick_interval_set(swigCPtr, this, value);
  }

  public int getTick_interval() {
    return libtorrent_jni.session_settings_tick_interval_get(swigCPtr, this);
  }

  public void setReport_web_seed_downloads(boolean value) {
    libtorrent_jni.session_settings_report_web_seed_downloads_set(swigCPtr, this, value);
  }

  public boolean getReport_web_seed_downloads() {
    return libtorrent_jni.session_settings_report_web_seed_downloads_get(swigCPtr, this);
  }

  public void setShare_mode_target(int value) {
    libtorrent_jni.session_settings_share_mode_target_set(swigCPtr, this, value);
  }

  public int getShare_mode_target() {
    return libtorrent_jni.session_settings_share_mode_target_get(swigCPtr, this);
  }

  public void setUpload_rate_limit(int value) {
    libtorrent_jni.session_settings_upload_rate_limit_set(swigCPtr, this, value);
  }

  public int getUpload_rate_limit() {
    return libtorrent_jni.session_settings_upload_rate_limit_get(swigCPtr, this);
  }

  public void setDownload_rate_limit(int value) {
    libtorrent_jni.session_settings_download_rate_limit_set(swigCPtr, this, value);
  }

  public int getDownload_rate_limit() {
    return libtorrent_jni.session_settings_download_rate_limit_get(swigCPtr, this);
  }

  public void setLocal_upload_rate_limit(int value) {
    libtorrent_jni.session_settings_local_upload_rate_limit_set(swigCPtr, this, value);
  }

  public int getLocal_upload_rate_limit() {
    return libtorrent_jni.session_settings_local_upload_rate_limit_get(swigCPtr, this);
  }

  public void setLocal_download_rate_limit(int value) {
    libtorrent_jni.session_settings_local_download_rate_limit_set(swigCPtr, this, value);
  }

  public int getLocal_download_rate_limit() {
    return libtorrent_jni.session_settings_local_download_rate_limit_get(swigCPtr, this);
  }

  public void setDht_upload_rate_limit(int value) {
    libtorrent_jni.session_settings_dht_upload_rate_limit_set(swigCPtr, this, value);
  }

  public int getDht_upload_rate_limit() {
    return libtorrent_jni.session_settings_dht_upload_rate_limit_get(swigCPtr, this);
  }

  public void setUnchoke_slots_limit(int value) {
    libtorrent_jni.session_settings_unchoke_slots_limit_set(swigCPtr, this, value);
  }

  public int getUnchoke_slots_limit() {
    return libtorrent_jni.session_settings_unchoke_slots_limit_get(swigCPtr, this);
  }

  public void setHalf_open_limit(int value) {
    libtorrent_jni.session_settings_half_open_limit_set(swigCPtr, this, value);
  }

  public int getHalf_open_limit() {
    return libtorrent_jni.session_settings_half_open_limit_get(swigCPtr, this);
  }

  public void setConnections_limit(int value) {
    libtorrent_jni.session_settings_connections_limit_set(swigCPtr, this, value);
  }

  public int getConnections_limit() {
    return libtorrent_jni.session_settings_connections_limit_get(swigCPtr, this);
  }

  public void setConnections_slack(int value) {
    libtorrent_jni.session_settings_connections_slack_set(swigCPtr, this, value);
  }

  public int getConnections_slack() {
    return libtorrent_jni.session_settings_connections_slack_get(swigCPtr, this);
  }

  public void setUtp_target_delay(int value) {
    libtorrent_jni.session_settings_utp_target_delay_set(swigCPtr, this, value);
  }

  public int getUtp_target_delay() {
    return libtorrent_jni.session_settings_utp_target_delay_get(swigCPtr, this);
  }

  public void setUtp_gain_factor(int value) {
    libtorrent_jni.session_settings_utp_gain_factor_set(swigCPtr, this, value);
  }

  public int getUtp_gain_factor() {
    return libtorrent_jni.session_settings_utp_gain_factor_get(swigCPtr, this);
  }

  public void setUtp_min_timeout(int value) {
    libtorrent_jni.session_settings_utp_min_timeout_set(swigCPtr, this, value);
  }

  public int getUtp_min_timeout() {
    return libtorrent_jni.session_settings_utp_min_timeout_get(swigCPtr, this);
  }

  public void setUtp_syn_resends(int value) {
    libtorrent_jni.session_settings_utp_syn_resends_set(swigCPtr, this, value);
  }

  public int getUtp_syn_resends() {
    return libtorrent_jni.session_settings_utp_syn_resends_get(swigCPtr, this);
  }

  public void setUtp_fin_resends(int value) {
    libtorrent_jni.session_settings_utp_fin_resends_set(swigCPtr, this, value);
  }

  public int getUtp_fin_resends() {
    return libtorrent_jni.session_settings_utp_fin_resends_get(swigCPtr, this);
  }

  public void setUtp_num_resends(int value) {
    libtorrent_jni.session_settings_utp_num_resends_set(swigCPtr, this, value);
  }

  public int getUtp_num_resends() {
    return libtorrent_jni.session_settings_utp_num_resends_get(swigCPtr, this);
  }

  public void setUtp_connect_timeout(int value) {
    libtorrent_jni.session_settings_utp_connect_timeout_set(swigCPtr, this, value);
  }

  public int getUtp_connect_timeout() {
    return libtorrent_jni.session_settings_utp_connect_timeout_get(swigCPtr, this);
  }

  public void setUtp_dynamic_sock_buf(boolean value) {
    libtorrent_jni.session_settings_utp_dynamic_sock_buf_set(swigCPtr, this, value);
  }

  public boolean getUtp_dynamic_sock_buf() {
    return libtorrent_jni.session_settings_utp_dynamic_sock_buf_get(swigCPtr, this);
  }

  public void setUtp_loss_multiplier(int value) {
    libtorrent_jni.session_settings_utp_loss_multiplier_set(swigCPtr, this, value);
  }

  public int getUtp_loss_multiplier() {
    return libtorrent_jni.session_settings_utp_loss_multiplier_get(swigCPtr, this);
  }

  public void setMixed_mode_algorithm(int value) {
    libtorrent_jni.session_settings_mixed_mode_algorithm_set(swigCPtr, this, value);
  }

  public int getMixed_mode_algorithm() {
    return libtorrent_jni.session_settings_mixed_mode_algorithm_get(swigCPtr, this);
  }

  public void setRate_limit_utp(boolean value) {
    libtorrent_jni.session_settings_rate_limit_utp_set(swigCPtr, this, value);
  }

  public boolean getRate_limit_utp() {
    return libtorrent_jni.session_settings_rate_limit_utp_get(swigCPtr, this);
  }

  public void setListen_queue_size(int value) {
    libtorrent_jni.session_settings_listen_queue_size_set(swigCPtr, this, value);
  }

  public int getListen_queue_size() {
    return libtorrent_jni.session_settings_listen_queue_size_get(swigCPtr, this);
  }

  public void setAnnounce_double_nat(boolean value) {
    libtorrent_jni.session_settings_announce_double_nat_set(swigCPtr, this, value);
  }

  public boolean getAnnounce_double_nat() {
    return libtorrent_jni.session_settings_announce_double_nat_get(swigCPtr, this);
  }

  public void setTorrent_connect_boost(int value) {
    libtorrent_jni.session_settings_torrent_connect_boost_set(swigCPtr, this, value);
  }

  public int getTorrent_connect_boost() {
    return libtorrent_jni.session_settings_torrent_connect_boost_get(swigCPtr, this);
  }

  public void setSeeding_outgoing_connections(boolean value) {
    libtorrent_jni.session_settings_seeding_outgoing_connections_set(swigCPtr, this, value);
  }

  public boolean getSeeding_outgoing_connections() {
    return libtorrent_jni.session_settings_seeding_outgoing_connections_get(swigCPtr, this);
  }

  public void setNo_connect_privileged_ports(boolean value) {
    libtorrent_jni.session_settings_no_connect_privileged_ports_set(swigCPtr, this, value);
  }

  public boolean getNo_connect_privileged_ports() {
    return libtorrent_jni.session_settings_no_connect_privileged_ports_get(swigCPtr, this);
  }

  public void setAlert_queue_size(int value) {
    libtorrent_jni.session_settings_alert_queue_size_set(swigCPtr, this, value);
  }

  public int getAlert_queue_size() {
    return libtorrent_jni.session_settings_alert_queue_size_get(swigCPtr, this);
  }

  public void setMax_metadata_size(int value) {
    libtorrent_jni.session_settings_max_metadata_size_set(swigCPtr, this, value);
  }

  public int getMax_metadata_size() {
    return libtorrent_jni.session_settings_max_metadata_size_get(swigCPtr, this);
  }

  public void setSmooth_connects(boolean value) {
    libtorrent_jni.session_settings_smooth_connects_set(swigCPtr, this, value);
  }

  public boolean getSmooth_connects() {
    return libtorrent_jni.session_settings_smooth_connects_get(swigCPtr, this);
  }

  public void setAlways_send_user_agent(boolean value) {
    libtorrent_jni.session_settings_always_send_user_agent_set(swigCPtr, this, value);
  }

  public boolean getAlways_send_user_agent() {
    return libtorrent_jni.session_settings_always_send_user_agent_get(swigCPtr, this);
  }

  public void setApply_ip_filter_to_trackers(boolean value) {
    libtorrent_jni.session_settings_apply_ip_filter_to_trackers_set(swigCPtr, this, value);
  }

  public boolean getApply_ip_filter_to_trackers() {
    return libtorrent_jni.session_settings_apply_ip_filter_to_trackers_get(swigCPtr, this);
  }

  public void setRead_job_every(int value) {
    libtorrent_jni.session_settings_read_job_every_set(swigCPtr, this, value);
  }

  public int getRead_job_every() {
    return libtorrent_jni.session_settings_read_job_every_get(swigCPtr, this);
  }

  public void setUse_disk_read_ahead(boolean value) {
    libtorrent_jni.session_settings_use_disk_read_ahead_set(swigCPtr, this, value);
  }

  public boolean getUse_disk_read_ahead() {
    return libtorrent_jni.session_settings_use_disk_read_ahead_get(swigCPtr, this);
  }

  public void setLock_files(boolean value) {
    libtorrent_jni.session_settings_lock_files_set(swigCPtr, this, value);
  }

  public boolean getLock_files() {
    return libtorrent_jni.session_settings_lock_files_get(swigCPtr, this);
  }

  public void setSsl_listen(int value) {
    libtorrent_jni.session_settings_ssl_listen_set(swigCPtr, this, value);
  }

  public int getSsl_listen() {
    return libtorrent_jni.session_settings_ssl_listen_get(swigCPtr, this);
  }

  public void setTracker_backoff(int value) {
    libtorrent_jni.session_settings_tracker_backoff_set(swigCPtr, this, value);
  }

  public int getTracker_backoff() {
    return libtorrent_jni.session_settings_tracker_backoff_get(swigCPtr, this);
  }

  public void setBan_web_seeds(boolean value) {
    libtorrent_jni.session_settings_ban_web_seeds_set(swigCPtr, this, value);
  }

  public boolean getBan_web_seeds() {
    return libtorrent_jni.session_settings_ban_web_seeds_get(swigCPtr, this);
  }

  public void setMax_http_recv_buffer_size(int value) {
    libtorrent_jni.session_settings_max_http_recv_buffer_size_set(swigCPtr, this, value);
  }

  public int getMax_http_recv_buffer_size() {
    return libtorrent_jni.session_settings_max_http_recv_buffer_size_get(swigCPtr, this);
  }

  public void setSupport_share_mode(boolean value) {
    libtorrent_jni.session_settings_support_share_mode_set(swigCPtr, this, value);
  }

  public boolean getSupport_share_mode() {
    return libtorrent_jni.session_settings_support_share_mode_get(swigCPtr, this);
  }

  public void setSupport_merkle_torrents(boolean value) {
    libtorrent_jni.session_settings_support_merkle_torrents_set(swigCPtr, this, value);
  }

  public boolean getSupport_merkle_torrents() {
    return libtorrent_jni.session_settings_support_merkle_torrents_get(swigCPtr, this);
  }

  public void setReport_redundant_bytes(boolean value) {
    libtorrent_jni.session_settings_report_redundant_bytes_set(swigCPtr, this, value);
  }

  public boolean getReport_redundant_bytes() {
    return libtorrent_jni.session_settings_report_redundant_bytes_get(swigCPtr, this);
  }

  public void setHandshake_client_version(String value) {
    libtorrent_jni.session_settings_handshake_client_version_set(swigCPtr, this, value);
  }

  public String getHandshake_client_version() {
    return libtorrent_jni.session_settings_handshake_client_version_get(swigCPtr, this);
  }

  public void setUse_disk_cache_pool(boolean value) {
    libtorrent_jni.session_settings_use_disk_cache_pool_set(swigCPtr, this, value);
  }

  public boolean getUse_disk_cache_pool() {
    return libtorrent_jni.session_settings_use_disk_cache_pool_get(swigCPtr, this);
  }

  public void setInactive_down_rate(int value) {
    libtorrent_jni.session_settings_inactive_down_rate_set(swigCPtr, this, value);
  }

  public int getInactive_down_rate() {
    return libtorrent_jni.session_settings_inactive_down_rate_get(swigCPtr, this);
  }

  public void setInactive_up_rate(int value) {
    libtorrent_jni.session_settings_inactive_up_rate_set(swigCPtr, this, value);
  }

  public int getInactive_up_rate() {
    return libtorrent_jni.session_settings_inactive_up_rate_get(swigCPtr, this);
  }

  public enum suggest_mode_t {
    no_piece_suggestions(libtorrent_jni.session_settings_no_piece_suggestions_get()),
    suggest_read_cache(libtorrent_jni.session_settings_suggest_read_cache_get());

    public final int swigValue() {
      return swigValue;
    }

    public static suggest_mode_t swigToEnum(int swigValue) {
      suggest_mode_t[] swigValues = suggest_mode_t.class.getEnumConstants();
      if (swigValue < swigValues.length && swigValue >= 0 && swigValues[swigValue].swigValue == swigValue)
        return swigValues[swigValue];
      for (suggest_mode_t swigEnum : swigValues)
        if (swigEnum.swigValue == swigValue)
          return swigEnum;
      throw new IllegalArgumentException("No enum " + suggest_mode_t.class + " with value " + swigValue);
    }

    @SuppressWarnings("unused")
    private suggest_mode_t() {
      this.swigValue = SwigNext.next++;
    }

    @SuppressWarnings("unused")
    private suggest_mode_t(int swigValue) {
      this.swigValue = swigValue;
      SwigNext.next = swigValue+1;
    }

    @SuppressWarnings("unused")
    private suggest_mode_t(suggest_mode_t swigEnum) {
      this.swigValue = swigEnum.swigValue;
      SwigNext.next = this.swigValue+1;
    }

    private final int swigValue;

    private static class SwigNext {
      private static int next = 0;
    }
  }

  public enum choking_algorithm_t {
    fixed_slots_choker,
    auto_expand_choker,
    rate_based_choker,
    bittyrant_choker;

    public final int swigValue() {
      return swigValue;
    }

    public static choking_algorithm_t swigToEnum(int swigValue) {
      choking_algorithm_t[] swigValues = choking_algorithm_t.class.getEnumConstants();
      if (swigValue < swigValues.length && swigValue >= 0 && swigValues[swigValue].swigValue == swigValue)
        return swigValues[swigValue];
      for (choking_algorithm_t swigEnum : swigValues)
        if (swigEnum.swigValue == swigValue)
          return swigEnum;
      throw new IllegalArgumentException("No enum " + choking_algorithm_t.class + " with value " + swigValue);
    }

    @SuppressWarnings("unused")
    private choking_algorithm_t() {
      this.swigValue = SwigNext.next++;
    }

    @SuppressWarnings("unused")
    private choking_algorithm_t(int swigValue) {
      this.swigValue = swigValue;
      SwigNext.next = swigValue+1;
    }

    @SuppressWarnings("unused")
    private choking_algorithm_t(choking_algorithm_t swigEnum) {
      this.swigValue = swigEnum.swigValue;
      SwigNext.next = this.swigValue+1;
    }

    private final int swigValue;

    private static class SwigNext {
      private static int next = 0;
    }
  }

  public enum seed_choking_algorithm_t {
    round_robin,
    fastest_upload,
    anti_leech;

    public final int swigValue() {
      return swigValue;
    }

    public static seed_choking_algorithm_t swigToEnum(int swigValue) {
      seed_choking_algorithm_t[] swigValues = seed_choking_algorithm_t.class.getEnumConstants();
      if (swigValue < swigValues.length && swigValue >= 0 && swigValues[swigValue].swigValue == swigValue)
        return swigValues[swigValue];
      for (seed_choking_algorithm_t swigEnum : swigValues)
        if (swigEnum.swigValue == swigValue)
          return swigEnum;
      throw new IllegalArgumentException("No enum " + seed_choking_algorithm_t.class + " with value " + swigValue);
    }

    @SuppressWarnings("unused")
    private seed_choking_algorithm_t() {
      this.swigValue = SwigNext.next++;
    }

    @SuppressWarnings("unused")
    private seed_choking_algorithm_t(int swigValue) {
      this.swigValue = swigValue;
      SwigNext.next = swigValue+1;
    }

    @SuppressWarnings("unused")
    private seed_choking_algorithm_t(seed_choking_algorithm_t swigEnum) {
      this.swigValue = swigEnum.swigValue;
      SwigNext.next = this.swigValue+1;
    }

    private final int swigValue;

    private static class SwigNext {
      private static int next = 0;
    }
  }

  public enum io_buffer_mode_t {
    enable_os_cache(libtorrent_jni.session_settings_enable_os_cache_get()),
    disable_os_cache_for_aligned_files(libtorrent_jni.session_settings_disable_os_cache_for_aligned_files_get()),
    disable_os_cache(libtorrent_jni.session_settings_disable_os_cache_get());

    public final int swigValue() {
      return swigValue;
    }

    public static io_buffer_mode_t swigToEnum(int swigValue) {
      io_buffer_mode_t[] swigValues = io_buffer_mode_t.class.getEnumConstants();
      if (swigValue < swigValues.length && swigValue >= 0 && swigValues[swigValue].swigValue == swigValue)
        return swigValues[swigValue];
      for (io_buffer_mode_t swigEnum : swigValues)
        if (swigEnum.swigValue == swigValue)
          return swigEnum;
      throw new IllegalArgumentException("No enum " + io_buffer_mode_t.class + " with value " + swigValue);
    }

    @SuppressWarnings("unused")
    private io_buffer_mode_t() {
      this.swigValue = SwigNext.next++;
    }

    @SuppressWarnings("unused")
    private io_buffer_mode_t(int swigValue) {
      this.swigValue = swigValue;
      SwigNext.next = swigValue+1;
    }

    @SuppressWarnings("unused")
    private io_buffer_mode_t(io_buffer_mode_t swigEnum) {
      this.swigValue = swigEnum.swigValue;
      SwigNext.next = this.swigValue+1;
    }

    private final int swigValue;

    private static class SwigNext {
      private static int next = 0;
    }
  }

  public enum disk_cache_algo_t {
    lru,
    largest_contiguous,
    avoid_readback;

    public final int swigValue() {
      return swigValue;
    }

    public static disk_cache_algo_t swigToEnum(int swigValue) {
      disk_cache_algo_t[] swigValues = disk_cache_algo_t.class.getEnumConstants();
      if (swigValue < swigValues.length && swigValue >= 0 && swigValues[swigValue].swigValue == swigValue)
        return swigValues[swigValue];
      for (disk_cache_algo_t swigEnum : swigValues)
        if (swigEnum.swigValue == swigValue)
          return swigEnum;
      throw new IllegalArgumentException("No enum " + disk_cache_algo_t.class + " with value " + swigValue);
    }

    @SuppressWarnings("unused")
    private disk_cache_algo_t() {
      this.swigValue = SwigNext.next++;
    }

    @SuppressWarnings("unused")
    private disk_cache_algo_t(int swigValue) {
      this.swigValue = swigValue;
      SwigNext.next = swigValue+1;
    }

    @SuppressWarnings("unused")
    private disk_cache_algo_t(disk_cache_algo_t swigEnum) {
      this.swigValue = swigEnum.swigValue;
      SwigNext.next = this.swigValue+1;
    }

    private final int swigValue;

    private static class SwigNext {
      private static int next = 0;
    }
  }

  public enum bandwidth_mixed_algo_t {
    prefer_tcp(libtorrent_jni.session_settings_prefer_tcp_get()),
    peer_proportional(libtorrent_jni.session_settings_peer_proportional_get());

    public final int swigValue() {
      return swigValue;
    }

    public static bandwidth_mixed_algo_t swigToEnum(int swigValue) {
      bandwidth_mixed_algo_t[] swigValues = bandwidth_mixed_algo_t.class.getEnumConstants();
      if (swigValue < swigValues.length && swigValue >= 0 && swigValues[swigValue].swigValue == swigValue)
        return swigValues[swigValue];
      for (bandwidth_mixed_algo_t swigEnum : swigValues)
        if (swigEnum.swigValue == swigValue)
          return swigEnum;
      throw new IllegalArgumentException("No enum " + bandwidth_mixed_algo_t.class + " with value " + swigValue);
    }

    @SuppressWarnings("unused")
    private bandwidth_mixed_algo_t() {
      this.swigValue = SwigNext.next++;
    }

    @SuppressWarnings("unused")
    private bandwidth_mixed_algo_t(int swigValue) {
      this.swigValue = swigValue;
      SwigNext.next = swigValue+1;
    }

    @SuppressWarnings("unused")
    private bandwidth_mixed_algo_t(bandwidth_mixed_algo_t swigEnum) {
      this.swigValue = swigEnum.swigValue;
      SwigNext.next = this.swigValue+1;
    }

    private final int swigValue;

    private static class SwigNext {
      private static int next = 0;
    }
  }

}
